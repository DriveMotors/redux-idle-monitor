<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/dispatcher.js | redux-idle-monitor API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/cchamberlain/redux-idle-monitor" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureActionDispatchers">configureActionDispatchers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createContext">createContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configure">configure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureMiddleware">configureMiddleware</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureReducer">configureReducer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-activityAction">activityAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-activityDetectionAction">activityDetectionAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-configureResetDispatcher">configureResetDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-configureStartDispatcher">configureStartDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-configureStopDispatcher">configureStopDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createActionDispatchers">createActionDispatchers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-defineAction">defineAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-resetHandler">resetHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-startHandler">startHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-stopHandler">stopHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ACTIVITY">ACTIVITY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ACTIVITY_DETECTION">ACTIVITY_DETECTION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LIB_NAME">LIB_NAME</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ROOT_STATE_KEY">ROOT_STATE_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getActions">getActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getActiveEvents">getActiveEvents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getLevel">getLevel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getThresholds">getThresholds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseFastState">getUseFastState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseLocalState">getUseLocalState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseWebRTCState">getUseWebRTCState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseWebSocketsState">getUseWebSocketsState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createDispatcher">createDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createLogger">createLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createMiddleware">createMiddleware</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createReducer">createReducer</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/dispatcher.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { assert } from &apos;chai&apos;
import { createStore } from &apos;redux&apos;
import { createAction } from &apos;redux-actions&apos;
import  { ROOT_STATE_KEY
        , ACTIVITY
        , ACTIVITY_DETECTION
        } from &apos;./constants&apos;
import { createActionDispatchers, startHandler, resetHandler, stopHandler } from &apos;./actions&apos;

import { createNoopStore, createLocalStore, bisectStore, configureReducer, createMergingReducer, createStoreMultiplexer, createActionMultiplexer } from &apos;redux-addons/lib/store&apos;


const createDispatcher = context =&gt; (dispatch, getState) =&gt; {
  /**
   * Multiplexer for calling dispatch and getState across all stores or individually.
   * @type {StoreMultiplexer}
   */
  const stores = createStoresDispatcher(context)(dispatch, getState)
  const detection = createDetectionDispatcher(context, { stores })(dispatch, getState)
  const action = createActionDispatcher(context, { stores, detection })(dispatch, getState)
  return { stores, detection, action }
}
export default createDispatcher


const createStoresDispatcher = context =&gt; (dispatch, getState) =&gt; {
  const { appActionNames, log, getAction, getActionType, getTimeoutMS, useFastStore, useLocalStore, initialActionName, getActionContextByName } = context

  const getPayloadCreator = actionName =&gt; getActionContextByName(actionName)
  const actionMapping = [ [ACTIVITY, { type: getActionType(ACTIVITY), payloadCreator: getPayloadCreator(ACTIVITY) }]
                        , [ACTIVITY_DETECTION, { type: getActionType(ACTIVITY_DETECTION),  payloadCreator: getPayloadCreator(ACTIVITY_DETECTION) }]
                        , ...appActionNames.map(x =&gt; [x, { type: getActionType(x), payloadCreator: getPayloadCreator(x) }])
                        ]

  const actionMultiplexer = createActionMultiplexer(actionMapping)


  const libStore = bisectStore({ dispatch, getState }, &apos;idle&apos;)
  let storesMapping = [ [ &apos;lib&apos;, libStore ] ]

  const createInitialFastState = () =&gt; ({ lastActive: +new Date(), lastEvent: { x: -1, y: -1 } })
  const createFastReducer = () =&gt; createMergingReducer(ACTIVITY)
  if(useFastStore)
    storesMapping.push([ &apos;fast&apos;, createStore(createFastReducer(), createInitialFastState()) ])

  const createInitialLocalState = () =&gt; ({ lastActive: +new Date() })
  const createLocalReducer = () =&gt; configureReducer(action =&gt; { lastActive: action.payload.lastActive }, false)(ACTIVITY)
  if(useLocalStore)
    storesMapping.push([ &apos;local&apos;, createLocalStore(createLocalReducer(), createInitialLocalState()) ])

  const stores = createStoreMultiplexer(storesMapping, actionMultiplexer)
  return stores
}

const createDetectionDispatcher = (context, { stores }) =&gt; (dispatch, getState) =&gt; {
  const { log, activeEvents, initialActionName, initialAction, thresholds, getActionType } = context
  const { dispatchAction } = stores


  /** Detects whether the activity should trigger a redux update */
  const _shouldActivityUpdate = ({ type, pageX, pageY }) =&gt; {
    if(type !== &apos;mousemove&apos;) return true

    const { lastActive, lastEvent: { x, y } } = stores.selectFirst(&apos;fast&apos;, &apos;lib&apos;).getState()

    if (typeof pageX === &apos;undefined&apos; || typeof pageY === &apos;undefined&apos;)
      return false
    if(Math.abs(pageX - x) &lt; thresholds.mouse &amp;&amp; Math.abs(pageY - y) &lt; thresholds.mouse)
      return false

    // SKIP UPDATE IF ITS UNDER THE THRESHOLD MS FROM THE LAST UPDATE
    let elapsedMS = (+new Date()) - lastActive
    if (elapsedMS &lt; thresholds.elapsedMS)
      return false
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.trace(`_shouldActivityUpdate: elapsed vs threshold =&gt; E[${elapsedMS}] &gt;= T[${thresholds.elapsedMS}], lastActive =&gt; ${lastActive}`)
    return true
  }


  /** One of the event listeners triggered an activity occurrence event. This gets spammed */
  const onActivity = e =&gt; {
    if (!_shouldActivityUpdate(e))
      return
    /*
    const { actionName } = stores.lib.getState()
    if(actionName !== initialActionName) {
      dispatchAction(initialActionName, { dispatch, getState, context })
      console.warn(&apos;RESET&apos;, actionName, initialActionName)
      //return dispatch(actions.reset)
    }
    */
    //console.warn(&apos;SKIP RESTART&apos;, actionName, initialActionName)
    dispatchAction(ACTIVITY, { })
    //stores.dispatch(actions.userActivity, { x: e.pageX, y: e.pageY})
    /** THIS WILL BE ROUTED TO FAST OR LOCAL STATE IF ENABLED */
  }

  const activityDetectionType = getActionType(ACTIVITY_DETECTION)

  return  { get isRunning() { return stores.lib.getState().isDetectionRunning }
          , start: () =&gt; {
              log.warn(&apos;activity detection starting...&apos;)
              if(process.env.NODE_ENV !== &apos;production&apos;)
                assert.ok(!stores.lib.getState().isDetectionRunning, &apos;activity detection is already running&apos;)
              activeEvents.forEach(x =&gt; document.addEventListener(x, onActivity))
              dispatchAction(ACTIVITY_DETECTION, { isDetectionRunning: true })

              //setState(ACTIVITY_DETECTION_ACTION, { isDetectionRunning: true })
            }
          , stop: () =&gt; {
              log.warn(&apos;activity detection terminating...&apos;)
              if(process.env.NODE_ENV !== &apos;production&apos;)
                assert(stores.lib.getState().isDetectionRunning === true, &apos;activity detection is not running&apos;)
              activeEvents.forEach(x =&gt; document.removeEventListener(x, onActivity))
              dispatchAction(ACTIVITY_DETECTION, { isDetectionRunning: false })
              //setState(ACTIVITY_DETECTION_ACTION, { isDetectionRunning: false })
            }
          }

}


const createActionDispatcher = (context, { stores, detection }) =&gt; (dispatch, getState) =&gt; {
  const { log, getTimeoutMS, getAction, getActionType, getNextActionName, useFastStore, setFastState } = context
  const _isPauseTriggered = timeoutMS =&gt; timeoutMS === null || timeoutMS === false || typeof timeoutMS === &apos;undefined&apos;
  const { dispatchAction } = stores

  /** Responsible for clearing old timeout and scheduling new one or immediately executing, returns new timeoutID or undefined */
  /*
  const scheduleObsolete = actionName =&gt; {
    timeout.clear()
    const delay = timeout.timeoutMS(actionName)
    log.info({ actionName, timeoutMS }, &apos;schedule&apos;)
    const meta = { delay: delay &gt; 0 ? delay : noop() }
    const args = { actionName, isPaused: _isPauseTriggered(timeoutMS), meta }

    if(timeoutMS &gt; 0) {

      //timeout.schedule(() =&gt; execute(args), timeoutMS)
      //return setTimeout(() =&gt; execute(args), timeoutMS)
    }

    execute(args)
  }
  */
  const getDelay = actionName =&gt; {
    let result = getTimeoutMS(actionName)
    return typeof result === &apos;function&apos; ? result(dispatch, getState, _getChildContext(context)) : result
  }
  //const executeIn = createAction(&apos;EXECUTE_IN&apos;, (actionName, delay) =&gt; ({ actionName }), (actionName, delay) =&gt; ({ delay }))

  /** Responsible for executing an action */
  const execute = ( actionName /*isPaused, meta*/ ) =&gt; {
    const ACTION_TYPE = getActionType(actionName)

    //const delay = getDelay(actionName)
    /*
    const isPaused = _isPauseTriggered(delay)
    const meta = { delay: delay &gt; 0 ? delay : (() =&gt; {})() }
    //const nextActionName = getNextActionName(actionName)
    //const nextDelay = nextActionName ? getDelay(nextActionName) : null
    */
    /*
    const libState = stores.lib.getState()
    const wasPaused = libState.isPaused
    const isDetectionRunning = libState.isDetectionRunning
    */

    /** SCHEDULE THE NEXT ACTION IF IT EXISTS */
    //const isLastAction = nextActionName === null || typeof nextActionName === &apos;undefined&apos;

    //log.info({ actionName, ACTION_TYPE, isPaused, wasPaused, isDetectionRunning, nextActionName }, &apos;execute&apos;)
    /** TODO: CHECK LOCAL STATE HERE AND IF ITS BEEN ACTIVE, POSTPONE THE ACTION ABOUT TO BE EXECUTED */

/*
    if((isLastAction || isPaused) &amp;&amp; isDetectionRunning) {
      detection.stop()
    }
    if(!(isLastAction || isPaused) &amp;&amp; !isDetectionRunning) {
      detection.start()
    }
    */




        /** UPDATE THE STATE OF THE APP */
        //console.warn(&apos;DISPATCHING NEXT IN &apos;, nextDelay)
    //let timeoutID = !isLastAction &amp;&amp; !isPaused &amp;&amp; nextDelay ? dispatchAction(nextActionName, { dispatch, getState, context }, { delay: nextDelay }) : null
    //const next = nextActionName =&gt; nextActionName ? dispatchAction(nextActionName, {}, { delay: getDelay(nextActionName) }) : detection.stop
    /*
    if(!isPaused &amp;&amp; !isDetectionRunning)
      detection.start()
    */
    /*
    if((!next || isPaused) &amp;&amp; isDetectionRunning) {
      detection.stop()
    }
    if(next &amp;&amp; !isPaused &amp;&amp; !isDetectionRunning) {
      detection.start()
    }
    */
    /*
    return dispatch(createAction(ACTION_TYPE), { actionName: actionName
                          , isIdle: typeof nextActionName === &apos;undefined&apos;
                          , isPaused
                          , meta
                          //, meta: { idle: true, delay: 4000 }
                          //, timeoutID
                          }())
                          */
    dispatchAction(actionName,  { actionName: actionName
                                //, isIdle: typeof next === &apos;undefined&apos;
                                //, isPaused
                                //, meta: { idle: true, delay: 4000 }
                                //, timeoutID
                                })
    /** EXECUTE THE USER DEFINED ACTION WITH REDUX THUNK ARGS + CONTEXT (LOG, START/STOP/RESET DISPATCHABLE ACTIONS) */
   // const { next, delay } =
    getAction(actionName)(dispatch, getState, _getChildContext(context))
    /*
    if(next)
      dispatchAction(next, {}, { delay })
    else
      detection.stop()
    */
  }
  return { execute }
}

const _getChildContext = context =&gt; ({ ...context, actions: createActionDispatchers(context) })











/*

class MemoryStore {
  constructor(stateKeys, initialState) {
    this._stateKeys = stateKeys
    this._state = initialState
    this._stateAccessor = this._stateKeys.reduce((stateAccessor, key) =&gt; {
      Object.defineProperty(stateAccessor, key, { get: () =&gt; this._state[key] })
      return stateAccessor
    }, {})
  }

  _shouldSetState = newState =&gt; Object.keys(newState).some(x =&gt; this._stateKeys.includes(x) &amp;&amp; typeof newState[x] !== &apos;undefined&apos;);

  _filterState = newState =&gt; {
    return Object.keys(newState).reduce((state, key) =&gt; {
      if(this._stateKeys.includes(key))
        state[key] = newState[key]
      return state
    }, {})
  };

  getState = () =&gt; {
    return this._stateAccessor
  };
  setState = (newState) =&gt; {
    if(!this._shouldSetState(newState))
      return
    console.warn(`SETTING FAST STATE =&gt; ${JSON.stringify(newState)}`)
    Object.keys(this._filterState(newState)).forEach(stateKey =&gt; this._state[stateKey] = newState[stateKey])
  };
}

*/
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
