<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/dispatcher.js | redux-idle-monitor API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/cchamberlain/redux-idle-monitor" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureActions">configureActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createContext">createContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createDispatcher">createDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configure">configure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureMiddleware">configureMiddleware</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureReducer">configureReducer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-activityAction">activityAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-activityDetectionAction">activityDetectionAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createActions">createActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createResetDispatcher">createResetDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createStartDispatcher">createStartDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createStopDispatcher">createStopDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-defineAction">defineAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ACTIVITY">ACTIVITY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ACTIVITY_DETECTION">ACTIVITY_DETECTION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LIB_NAME">LIB_NAME</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ROOT_STATE_KEY">ROOT_STATE_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getActions">getActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getActiveEvents">getActiveEvents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getLevel">getLevel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getThresholds">getThresholds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseFastState">getUseFastState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseLocalState">getUseLocalState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseWebRTCState">getUseWebRTCState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseWebSocketsState">getUseWebSocketsState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createLogger">createLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createMiddleware">createMiddleware</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createReducer">createReducer</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/dispatcher.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { assert } from &apos;chai&apos;
import { createAction } from &apos;redux-actions&apos;
import  { ROOT_STATE_KEY
        , ACTIVITY
        , ACTIVITY_DETECTION
        } from &apos;./constants&apos;
import { createActions, createStart, createReset, createStop } from &apos;./actions&apos;


class MemoryStore {
  constructor(stateKeys, initialState) {
    this._stateKeys = stateKeys
    this._state = initialState
    this._stateAccessor = this._stateKeys.reduce((stateAccessor, key) =&gt; {
      Object.defineProperty(stateAccessor, key, { get: () =&gt; this._state[key] })
      return stateAccessor
    }, {})
  }

  _shouldSetState = newState =&gt; Object.keys(newState).some(x =&gt; this._stateKeys.includes(x) &amp;&amp; typeof newState[x] !== &apos;undefined&apos;);

  _filterState = newState =&gt; {
    return Object.keys(newState).reduce((state, key) =&gt; {
      if(this._stateKeys.includes(key))
        state[key] = newState[key]
      return state
    }, {})
  };

  getState = () =&gt; {
    return this._stateAccessor
  };
  setState = (newState) =&gt; {
    if(!this._shouldSetState(newState))
      return
    console.warn(`SETTING FAST STATE =&gt; ${JSON.stringify(newState)}`)
    Object.keys(this._filterState(newState)).forEach(stateKey =&gt; this._state[stateKey] = newState[stateKey])
  };
}

export default function createDispatcher(context) {
  return (dispatch, getState) =&gt; {
    const stores = createStoresDispatcher(context)(dispatch, getState)
    //const timeout = createTimeoutDispatcher(context, { stores })(dispatch, getState)
    const detection = createDetectionDispatcher(context, { stores /* timeout */ })(dispatch, getState)
    const action = createActionDispatcher(context, { /* timeout, */ stores, detection })(dispatch, getState)
    return { stores, /*timeout, */ detection, action }
  }
}

const createStoresDispatcher = context =&gt; (dispatch, getState) =&gt; {
  const { log, getAction, getTimeoutMS, useFastState, useLocalState, initialLastEvent } = context

  const fastStateKeys = [&apos;lastActive&apos;, &apos;lastEvent&apos;, &apos;timeoutID&apos;, &apos;isDetectionRunning&apos;]
  const localStateKeys = [&apos;lastActive&apos;]
  const reduxStateKeys = [&apos;actionName&apos;, &apos;isIdle&apos;, &apos;isPaused&apos;, &apos;lastActive&apos;, &apos;lastEvent&apos;, &apos;timeoutID&apos;, &apos;isDetectionRunning&apos;]

  const _shouldSetState = (newState, stateKeys) =&gt; Object.keys(newState).some(x =&gt; fastStateKeys.includes(x) &amp;&amp; typeof newState[x] !== &apos;undefined&apos;)

  const _shouldSetFastState = newState =&gt; useFastState &amp;&amp; _shouldSetState(newState, fastStateKeys)
  const _shouldSetLocalState = newState =&gt; useLocalState &amp;&amp; _shouldSetState(newState, localStateKeys)
  const _shouldSetReduxState = newState =&gt; _shouldSetState(newState, reduxStateKeys)


  const _filterState = (newState, stateKeys) =&gt; {
    return Object.keys(newState).reduce((state, key) =&gt; {
      if(stateKeys.includes(key))
        state[key] = newState[key]
      return state
    }, {})
  }

/*
  const createFastState = ( { lastEvent = initialLastEvent
                            , timeoutID } = {}) =&gt; ({ lastActive: +new Date()
                                                    , lastEvent
                                                    , timeoutID
                                                    , isDetectionRunning: false
                                                    })
                                                    */
  let fastState = useFastState ? new MemoryStore(fastStateKeys, { lastActive: +new Date(), lastEvent: { x: 0, y: 0}, isDetectionRunning: false }) : noop()
  /*
  const setFastState = newState =&gt; {
    Object.keys(_filterState(newState, fastStateKeys)).forEach(stateKey =&gt; fastState[stateKey] = newState[stateKey])

    //fastState = Object.assign({}, fastState, _filterState(newState, fastStateKeys), { lastActive: +new Date() })
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.debug({ fastState }, &apos;fastState set&apos;)
  }
  const _stateGetter = (stateStore, stateKeys) =&gt; {
    return stateKeys.reduce((stateAccessor, key) =&gt; {
      Object.defineProperty(stateAccessor, key, { get: () =&gt; stateStore[key] })
      return stateAccessor
    }, {})
  }
  */

  //const fastStateGetter = _stateGetter(fastState, fastStateKeys)

  const createLocalState = ({} = {}) =&gt; ({ lastActive: +new Date() })
  /*
  if(useLocalState)
    localStorage[IDLEMONITOR_ACTIVITY] = createLocalState()
  */
  const getLocalState = () =&gt; {
    /*
    return localStateKeys.reduce((state, key) =&gt; {
      state[key] = localStorage[`${IDLEMONITOR_ACTIVITY}_${key}`]
      return state
    }, {})
    */
  }
  const setLocalState = (newState) =&gt; {
    /*
    localStorage[`${IDLEMONITOR_ACTIVITY}_lastActive`] = +new Date()
    Object.keys(newState).filter(key =&gt; localStateKeys.includes(key)).forEach((key) =&gt; localStorage[`${IDLEMONITOR_ACTIVITY}_${key}`] = newState[key])
    //localStorage[IDLEMONITOR_ACTIVITY] = Object.assign({}, localStorage[IDLEMONITOR_ACTIVITY], _filterState(newState, localStateKeys), { lastActive: +new Date() })
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.trace({ localState: getLocalState() }, &apos;localState set&apos;)
    */
  }

  /** GETS THIS LIBS SLICE OF TOP LEVEL STATE FROM REDUX (supports immutable) */
  const getLibState = () =&gt; {
    const state = getState()
    return state.isMap &amp;&amp; state.isMap() ? state.get(ROOT_STATE_KEY) : state[ROOT_STATE_KEY]
  }

  /** ABSTRACTS ACCESS TO STATE VIA GETTERS */
  const getLibStateAccessor = libState =&gt; {
    const fast = useFastState ? fastState.getState() : null

              /** The current state name */
    return  { get actionName() { return libState.actionName }
              /** Is in idle state (no more states to progress to) */
            , get isIdle() { return libState.isIdle }
              /** State can be paused manually or via action dispatch or returning null/undefined from timeoutMS function */
            , get isPaused() { return libState.isPaused }
              /** The epoch MS that the user was last active */
            , get lastActive() { return useFastState ? fast.lastActive : libState.lastActive }
              /** Event information captured on the last recorded user action */
            , get lastEvent() { return useFastState ? fast.lastEvent : libState.lastEvent }
              /** The timeoutID for the current scheduled next event if it exists */
            , get timeoutID() { return useFastState ? fast.timeoutID : libState.timeoutID }
              /** The timeoutID for the current scheduled next event if it exists */
            , get isDetectionRunning() { return useFastState ? fast.isDetectionRunning : libState.isDetectionRunning }
            }
  }

  const getReduxState = () =&gt; {
    const state = getLibStateAccessor(getLibState())

    return  { ...state
            , get next() {
                const events = context.actionNames
                const nextIndex = events.indexOf(state.actionName) + 1
                return events[nextIndex] /** MAY BE UNDEFINED */
              }
            , get action() { return getAction(state.actionName) }
            , get timeoutMS() { return getTimeoutMS(state.actionName) }
            , get remainingMS() {
                if(state.isIdle)
                  return 0
                const remainingMS = getTimeoutMS(state.actionName) - (+new Date() - state.lastActive)
                return remainingMS &gt; 0 ? remainingMS : 0
              }
            }
  }


  return  { get redux() { return getReduxState() }
            /** Without some way to track fast state (mousemove events), redux gets spammed with actions */
          , get fast() { return useFastState ? fastState.getState() : getReduxState() }
            /** Things that need to be synced across tabs (lastActive, lastEvent) */
          , get local() { return {} }
            /** All state update actions flow through this, has ability to bypass redux for fast state operations or dispatch to it */
          , setState: (actionName, newState) =&gt; {
              if(_shouldSetLocalState)
                setLocalState(newState)
              if(_shouldSetFastState(newState)) {
                fastState.setState(newState)
                //setFastState(newState)
                //if(!_shouldSetReduxState(newState))
                  //return log.debug(&apos;bypassing redux state update&apos;)
              }
              log.debug({ newState }, &apos;updating redux state&apos;)
              return dispatch(createAction(actionName)(newState))
            }
          }
}

const createTimeoutDispatcher = (context, { stores }) =&gt; (dispatch, getState) =&gt; {
  /*
  const { log, activeEvents, initialActionName, initialAction, thresholds, getActionType, getFastState, getTimeoutMS } = context
  const { setState } = stores

  const ACTIVITY_ACTION = getActionType(ACTIVITY)

  const clear = () =&gt; {
    //const timeoutID = stores.fast.timeoutID
    console.warn(`CLEARING TIMEOUTID =&gt; ${window.lastTimeoutID}`)
    clearTimeout(window.lastTimeoutID)
  }
  const schedule = (action, ms) =&gt; {
    clear()
    window.lastAction = action
    window.lastMS = ms
    window.lastTimeoutID = setTimeout(() =&gt; action(), ms)
    console.warn(&apos;NEW TIMEOUT SCHEDULED&apos;)
    //setState(ACTIVITY_ACTION, { timeoutID })
  }
  const reschedule = () =&gt; {
    schedule(window.lastAction, window.lastMS)
  }
  return  { clear
          , timeoutMS: actionName =&gt; {
              let result = getTimeoutMS(actionName)
              return typeof result === &apos;function&apos; ? result(dispatch, getState, _getChildContext(context)) : result
            }
          , schedule
          , reschedule
          }
          */
}

const createDetectionDispatcher = (context, { stores }) =&gt; (dispatch, getState) =&gt; {
  const { log, activeEvents, initialActionName, initialAction, thresholds, getActionType } = context
  const { setState } = stores

  const ACTIVITY_ACTION = getActionType(ACTIVITY)
  const ACTIVITY_DETECTION_ACTION = getActionType(ACTIVITY_DETECTION)


  /** Detects whether the activity should trigger a redux update */
  const _shouldActivityUpdate = ({ type, pageX, pageY }) =&gt; {
    if(type !== &apos;mousemove&apos;) return true

    const { lastActive, lastEvent: { x, y } } = stores.fast
    if (typeof pageX === &apos;undefined&apos; || typeof pageY === &apos;undefined&apos;)
      return false
    if(Math.abs(pageX - x) &lt; thresholds.mouse &amp;&amp; Math.abs(pageY - y) &lt; thresholds.mouse)
      return false

    // SKIP UPDATE IF ITS UNDER THE THRESHOLD MS FROM THE LAST UPDATE
    let elapsedMS = (+new Date()) - lastActive
    if (elapsedMS &lt; thresholds.elapsedMS)
      return false
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.trace(`_shouldActivityUpdate: elapsed vs threshold =&gt; E[${elapsedMS}] &gt;= T[${thresholds.elapsedMS}], lastActive =&gt; ${lastActive}`)
    return true
  }

  const _shouldRestart = () =&gt; stores.redux.actionName !== initialActionName

  /** One of the event listeners triggered an activity occurrence event. This gets spammed */
  const onActivity = e =&gt; {
    if (!_shouldActivityUpdate(e))
      return
    if(_shouldRestart()) {
      console.warn(&apos;NO SKIP RESTART&apos;, stores.redux.actionName, initialActionName)
      return dispatch(createReset(context))
    }
    console.warn(&apos;SKIP RESTART&apos;, stores.redux.actionName, initialActionName)
    //timeout.reschedule()
    /** THIS WILL BE ROUTED TO FAST OR LOCAL STATE IF ENABLED */
    setState(ACTIVITY_ACTION, { lastActive: +new Date(), lastEvent: { x: e.pageX, y: e.pageY } })
  }

  const activityDetectionType = getActionType(ACTIVITY_DETECTION)

  return  { get isRunning() { return stores.redux.isDetectionRunning }
          , start: () =&gt; {
              log.warn(&apos;activity detection starting...&apos;)
              if(process.env.NODE_ENV !== &apos;production&apos;)
                assert(stores.redux.isDetectionRunning === false, &apos;activity detection is already running&apos;)
              activeEvents.forEach(x =&gt; document.addEventListener(x, onActivity))
              setState(ACTIVITY_DETECTION_ACTION, { isDetectionRunning: true })
            }
          , stop: () =&gt; {
              log.warn(&apos;activity detection terminating...&apos;)
              if(process.env.NODE_ENV !== &apos;production&apos;)
                assert(stores.redux.isDetectionRunning === true, &apos;activity detection is not running&apos;)
              activeEvents.forEach(x =&gt; document.removeEventListener(x, onActivity))
              setState(ACTIVITY_DETECTION_ACTION, { isDetectionRunning: false })
            }
          }

}


const createActionDispatcher = (context, { stores, detection }) =&gt; (dispatch, getState) =&gt; {
  const { log, getTimeoutMS, getAction, getActionType, getNextActionName, useFastState, setFastState } = context
  const { setState } = stores
  const _isPauseTriggered = timeoutMS =&gt; timeoutMS === null || timeoutMS === false || typeof timeoutMS === &apos;undefined&apos;

  /** Responsible for clearing old timeout and scheduling new one or immediately executing, returns new timeoutID or undefined */
  /*
  const scheduleObsolete = actionName =&gt; {
    timeout.clear()
    const delay = timeout.timeoutMS(actionName)
    log.info({ actionName, timeoutMS }, &apos;schedule&apos;)
    const meta = { delay: delay &gt; 0 ? delay : noop() }
    const args = { actionName, isPaused: _isPauseTriggered(timeoutMS), meta }

    if(timeoutMS &gt; 0) {

      //timeout.schedule(() =&gt; execute(args), timeoutMS)
      //return setTimeout(() =&gt; execute(args), timeoutMS)
    }

    execute(args)
  }
  */
  const getDelay = actionName =&gt; {
    let result = getTimeoutMS(actionName)
    return typeof result === &apos;function&apos; ? result(dispatch, getState, _getChildContext(context)) : result
  }
  const executeIn = createAction(&apos;EXECUTE_IN&apos;, (actionName, delay) =&gt; ({ actionName }), (actionName, delay) =&gt; ({ delay }))

  /** Responsible for executing an action */
  const execute = ( actionName /*isPaused, meta*/ ) =&gt; {
    const ACTION_TYPE = getActionType(actionName)

    const delay = getDelay(actionName)
    const isPaused = _isPauseTriggered(delay)
    const meta = { delay: delay &gt; 0 ? delay : (() =&gt; {})() }
    const nextActionName = getNextActionName(actionName)
    const nextDelay = nextActionName ? getDelay(nextActionName) : null
    const reduxStore = stores.redux
    const wasPaused = reduxStore.isPaused
    const isDetectionRunning = reduxStore.isDetectionRunning

    /** SCHEDULE THE NEXT ACTION IF IT EXISTS */
    const isLastAction = nextActionName === null || typeof nextActionName === &apos;undefined&apos;

    log.info({ actionName, ACTION_TYPE, isPaused, wasPaused, isDetectionRunning, nextActionName }, &apos;execute&apos;)
    /** TODO: CHECK LOCAL STATE HERE AND IF ITS BEEN ACTIVE, POSTPONE THE ACTION ABOUT TO BE EXECUTED */

    if((isLastAction || isPaused) &amp;&amp; isDetectionRunning) {
      detection.stop()
    }
    if(!(isLastAction || isPaused) &amp;&amp; !isDetectionRunning) {
      detection.start()
    }




        /** UPDATE THE STATE OF THE APP */
        console.warn(&apos;DISPATCHING NEXT IN &apos;, nextDelay)
    let timeoutID = !isLastAction &amp;&amp; !isPaused &amp;&amp; nextDelay ? dispatch(executeIn(nextActionName, nextDelay)) : null
    /*
    return dispatch(createAction(ACTION_TYPE), { actionName: actionName
                          , isIdle: typeof nextActionName === &apos;undefined&apos;
                          , isPaused
                          , meta
                          //, meta: { idle: true, delay: 4000 }
                          //, timeoutID
                          }())
                          */
    setState(ACTION_TYPE, { actionName: actionName
                          , isIdle: typeof nextActionName === &apos;undefined&apos;
                          , isPaused
                          //, meta: { idle: true, delay: 4000 }
                          //, timeoutID
                          })
    /** EXECUTE THE USER DEFINED ACTION WITH REDUX THUNK ARGS + CONTEXT (LOG, START/STOP/RESET DISPATCHABLE ACTIONS) */
    getAction(actionName)(dispatch, getState, _getChildContext(context))
  }
  return { execute }
}

const _getChildContext = context =&gt; ({ ...context, actions: createActions(context) })
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
